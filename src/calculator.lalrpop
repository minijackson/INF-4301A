use std::str::FromStr;

use ast::{Expr,OpCode};

grammar;

Tier<Op, NextTier>: Box<Expr> = {
    <lhs:Tier<Op, NextTier>> <op:Op> <rhs:NextTier> => Box::new(Expr::BinaryOp(lhs, rhs, op)),
    NextTier
};

pub Expression = Tier<ExprOp, Term>;
ExprOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

pub Term = Tier<TermOp, Factor>;
TermOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

pub FunctionCall: Box<Expr> = {
    <name:Identifier> "(" <args:Args> ")" => Box::new(Expr::Function(name, args))
};

pub Factor: Box<Expr> = { <Num>, "(" <Expression> ")", <FunctionCall> };

Num: Box<Expr> = r"[0-9]+" => Box::new(Expr::Num(i32::from_str(<>).unwrap()));

Identifier: String = r"[[:alpha:]][[:alnum:]]*" => String::from_str(<>).unwrap();

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Args = Comma<Expression>;
