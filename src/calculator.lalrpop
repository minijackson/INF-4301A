use std::str::FromStr;

use ast::{NaiveExprs,NaiveExpr,BinaryOpCode,UnaryOpCode,NaiveBinding};

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Expressions: NaiveExprs = {
    <Comma<Expression>> => NaiveExprs { exprs: <> }
};

pub Expression: Box<NaiveExpr> = {
    Tier0
};

//==================
//== Control Flow ==
//==================

Tier0: Box<NaiveExpr> = {
    IfExp,
    Let,
    Tier1
};

IfExp: Box<NaiveExpr> = {
    "if" <cond:Expression> "then" <true_branch:Expression> "else" <false_branch:Expression>
        => Box::new(NaiveExpr::If(cond, true_branch, false_branch))
};

Let: Box<NaiveExpr> = {
    "let" <assignments:(<Assignment>)*> <assignment:Assignment> "in" <exprs:Expressions> "end"
        => {
            let mut assignments = assignments;
            assignments.push(assignment);
            Box::new(NaiveExpr::Let(assignments, exprs))
        }
};

Assignment: NaiveBinding = {
    "var" <name:Identifier> ":=" <exp:Expression> => NaiveBinding{ variable: name, value: *exp }
};

//===============
//== Operators ==
//===============

BinOpTier<Op, NextTier>: Box<NaiveExpr> = {
    <lhs:BinOpTier<Op, NextTier>> <op:Op> <rhs:NextTier> => Box::new(NaiveExpr::BinaryOp(lhs, rhs, op)),
    NextTier
};

Tier1 = BinOpTier<ExprOp, Tier2>;
ExprOp: BinaryOpCode = {
    "+" => BinaryOpCode::Add,
    "-" => BinaryOpCode::Sub,
};

Tier2 = BinOpTier<TermOp, UnaryOpExp>;
TermOp: BinaryOpCode = {
    "*" => BinaryOpCode::Mul,
    "/" => BinaryOpCode::Div,
};

UnaryOpExp: Box<NaiveExpr> = {
    <sign:UnaryOp> <value:Factor> => Box::new(NaiveExpr::UnaryOp(value, sign)),
    Factor
};

UnaryOp: UnaryOpCode = {
    "" => UnaryOpCode::Plus,
    "+" => UnaryOpCode::Plus,
    "-" => UnaryOpCode::Minus
};

//==========
//== Rest ==
//==========

FunctionCall: Box<NaiveExpr> = {
    <name:Identifier> "(" <args:Args> ")" => Box::new(NaiveExpr::Function(name, args))
};

Args = Comma<Expression>;

pub Factor: Box<NaiveExpr> = {
    <Variable>,
    <Num>,
    "(" <Expressions> ")" => Box::new(NaiveExpr::Grouping(<>)),
    <FunctionCall>
};

Variable: Box<NaiveExpr> = <Identifier> => Box::new(NaiveExpr::Variable(<>));

Num: Box<NaiveExpr> = r"[0-9]+" => Box::new(NaiveExpr::Num(i32::from_str(<>).unwrap()));

Identifier: String = r"[[:alpha:]][[:alnum:]]*" => String::from_str(<>).unwrap();
