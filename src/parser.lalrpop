use ast::{Exprs,Expr,BinaryOpCode,UnaryOpCode,Binding};
use type_sys;

use std::str::FromStr;

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Expressions: Exprs = {
    <Comma<Expression>> => Exprs { exprs: <> }
};

pub Expression: Box<Expr> = {
    Tier0
};

//==================
//== Control Flow ==
//==================

Tier0: Box<Expr> = {
    If, While,
    Tier1
};

If: Box<Expr> = {
    "if" <cond:Expression> "then" <true_branch:Expression> "else" <false_branch:Expression>
        => Box::new(Expr::If(cond, true_branch, false_branch))
};

While: Box<Expr> = {
    "while" <cond:Expression> "do" <something:Expression>
        => Box::new(Expr::While(cond, something))
};

//===============
//== Operators ==
//===============

Tier1: Box<Expr> = {
    <var:Identifier> ":=" <value:Expression> => Box::new(Expr::Assign(var, value)),
    Tier2
};

BinOpTier<Op, NextTier>: Box<Expr> = {
    <lhs:BinOpTier<Op, NextTier>> <op:Op> <rhs:NextTier>
        => Box::new(Expr::BinaryOp(lhs, rhs, op)),
    NextTier
};

Tier2 = BinOpTier<Tier2Op, Tier3>;
Tier2Op: BinaryOpCode = {
    "="  => BinaryOpCode::Eq,
    "<>" => BinaryOpCode::Ne,
};

Tier3 = BinOpTier<Tier3Op, Tier4>;
Tier3Op: BinaryOpCode = {
    "<"  => BinaryOpCode::Lt,
    "<=" => BinaryOpCode::Le,
    ">"  => BinaryOpCode::Gt,
    ">=" => BinaryOpCode::Ge,
};

Tier4 = BinOpTier<Tier4Op, Tier5>;
Tier4Op: BinaryOpCode = {
    "+" => BinaryOpCode::Add,
    "-" => BinaryOpCode::Sub,
};

Tier5 = BinOpTier<Tier5Op, UnaryOpExp>;
Tier5Op: BinaryOpCode = {
    "*" => BinaryOpCode::Mul,
    "/" => BinaryOpCode::Div,
};

UnaryOpExp: Box<Expr> = {
    <sign:UnaryOp> <value:Factor> => Box::new(Expr::UnaryOp(value, sign)),
    Factor
};

UnaryOp: UnaryOpCode = {
    "" => UnaryOpCode::Plus,
    "+" => UnaryOpCode::Plus,
    "-" => UnaryOpCode::Minus
};

//==========
//== Rest ==
//==========

pub Factor: Box<Expr> = {
    Let,
    Variable,
    Value,
    "(" <Expression> ")" => <>,
    "(" <expr:Expression> "," <exprs:Expressions> ")" => {
        let mut exprs = exprs;
        exprs.exprs.insert(0, expr);
        Box::new(Expr::Grouping(exprs))
    },
    FunctionCall
};

Let: Box<Expr> = {
    "let" <declarations:(<Declaration>)*> "in" <exprs:Expressions> "end"
        => Box::new(Expr::Let(declarations, exprs))
};

Declaration: Binding = {
    "var" <name:Identifier> ":=" <exp:Expression>
        => Binding{ variable: name, value: *exp }
};

FunctionCall: Box<Expr> = {
    <name:Identifier> "(" <args:Args> ")"
        => Box::new(Expr::Function(name, args))
};

Args = Comma<Expression>;

Variable: Box<Expr> = <Identifier> => Box::new(Expr::Variable(<>));

Value: Box<Expr> = {
    r"[0-9]+" => Box::new(Expr::Value(
                    type_sys::Value::Integer(
                        i32::from_str(<>).unwrap()
                        )
                    )
                 ),
    r"[0-9]+\.[0-9]*" => Box::new(Expr::Value(
                    type_sys::Value::Float(
                        f32::from_str(<>).unwrap()
                        )
                    )
                 ),
    "true"  => Box::new(Expr::Value(type_sys::Value::Bool(true))),
    "false" => Box::new(Expr::Value(type_sys::Value::Bool(false))),
};

Identifier: String = r"[[:alpha:]][[:alnum:]_]*" => <>.to_string();
